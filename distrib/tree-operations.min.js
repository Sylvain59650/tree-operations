'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @license
 * tree-operations 0.0.1
 * Copyright Sylvain Longep√©e
 * Released under MIT license <https://github.com/Sylvain59650/tree-operations/blob/master/LICENSE>
 */

;
(function (moduleName, root, factory) {
  if (typeof define === 'function' && define.amd) {
    // define([""], factory);
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    module.exports = factory();
  } else {
    window.TreeOps = factory();
  }
})("TreeModule", undefined, function () {
  'use strict';

  function TreeOps() {}

  TreeOps.toFlatArray = function (tree, childrenPropertyName, reversible) {
    if (reversible != true) reversible = false;
    var stack = tree && tree.length ? [{ pointer: tree, offset: 0, ref: null }] : [];
    var flat = [];
    var current = null;
    var i = 1;
    while (stack.length) {
      current = stack.pop();
      current.parentId = current.node ? current.node._id : null;
      while (current.offset < current.pointer.length) {
        var node = current.pointer[current.offset];
        if (reversible) {
          node._id = i;
          node._parentId = current.ref;
        }
        var children = node[childrenPropertyName];
        delete node[childrenPropertyName];
        flat.push(node);
        current.offset++;
        if (children) {
          stack.push(current);
          current = {
            pointer: children,
            offset: 0,
            node: node,
            ref: node._id
          };
        }
        i++;
      }
    }
    return flat;
  };

  TreeOps.fromArray = function (list, predicateChild) {
    var childrenPropertyName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "childs";

    debugger;
    return list.reduce(function (tree, node) {
      var parentNode = list.find(function (parent) {
        return predicateChild(node, parent);
      });
      if (parentNode === undefined) {
        tree.push(node);
      } else {
        if (!parentNode[childrenPropertyName]) {
          parentNode[childrenPropertyName] = [];
        }
        parentNode[childrenPropertyName].push(node);
      }
      return tree;
    }, []);
  };

  TreeOps.find = function (tree, predicateFind, predicateChild) {
    var childrenPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "childs";

    if (!tree) return undefined;
    var found = tree.find(predicateFind);
    if (found) {
      return found;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = tree[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var branch = _step.value;

        var childrens = branch[childrenPropertyName];
        if (!childrens) continue;
        found = this.find(childrens, predicateFind, predicateChild, childrenPropertyName);
        if (found) {
          return found;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return undefined;
  };

  return TreeOps;
});